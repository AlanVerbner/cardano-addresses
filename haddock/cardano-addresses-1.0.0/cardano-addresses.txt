-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library utilities for mnemonic generation and address derivation.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/cardano-addresses</a>
@package cardano-addresses
@version 1.0.0

module Cardano.Mnemonic

-- | Ease the manipulation of <a>Mnemonic</a> by encapsulating the type
--   constraints inside a constructor. This is particularly useful for
--   functions which do not require anything but a valid <a>Mnemonic</a>
--   without any particular pre-condition on the size of the
--   <a>Mnemonic</a> itself.
data SomeMnemonic
[SomeMnemonic] :: forall mw. KnownNat mw => Mnemonic mw -> SomeMnemonic

-- | This class enables caller to parse text list of variable length into
--   mnemonic sentences.
--   
--   Note that the given <a>Nat</a>s **have** to be valid mnemonic sizes,
--   otherwise the underlying code won't even compile, with not-so-friendly
--   error messages.
class MkSomeMnemonic (sz :: [Nat])

-- | Construct a mnemonic from a list of words. This function is
--   particularly useful when the number of words is not necessarily known
--   at runtime. The function is however <i>ambiguous</i> and requires
--   thereby a type application.
--   
--   <b>examples:</b>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 12 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Left "Invalid number of words: 12 words are expected."
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 9, 12, 15 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Right (SomeMnemonic ...)
--   </pre>
mkSomeMnemonic :: MkSomeMnemonic sz => [Text] -> Either (MkSomeMnemonicError sz) SomeMnemonic

-- | Error reported from trying to create a passphrase from a given
--   mnemonic
newtype MkSomeMnemonicError (sz :: [Nat])
MkSomeMnemonicError :: String -> MkSomeMnemonicError
[getMkSomeMnemonicError] :: MkSomeMnemonicError -> String

-- | Convert a <a>SomeMnemonic</a> to bytes.
someMnemonicToBytes :: SomeMnemonic -> ScrubbedBytes

-- | Small helper to collect <a>Nat</a> values from a type-level list
class NatVals (ns :: [Nat])
natVals :: NatVals ns => Proxy ns -> [Integer]

-- | Smart-constructor for <a>Mnemonic</a>. Requires a type application to
--   disambiguate the mnemonic size.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkMnemonic @15 sentence
--   Mnemonic {} :: Mnemonic 15
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkMnemonic (mnemonicToText mnemonic) == Right mnemonic
--   </pre>
mkMnemonic :: forall (mw :: Nat) (ent :: Nat) csz. (ConsistentEntropy ent mw csz, EntropySize mw ~ ent) => [Text] -> Either (MkMnemonicError csz) (Mnemonic mw)

-- | This wraps errors from <a>Cardano.Encoding.BIP39</a>
data MkMnemonicError csz

-- | Wrong number of words in mnemonic.
ErrMnemonicWords :: MnemonicWordsError -> MkMnemonicError csz

-- | Invalid entropy length or checksum.
ErrEntropy :: EntropyError csz -> MkMnemonicError csz

-- | Invalid word in mnemonic.
ErrDictionary :: DictionaryError -> MkMnemonicError csz

-- | Convert a <a>Mnemonic</a> to a sentence of English mnemonic words.
mnemonicToText :: Mnemonic mw -> [Text]

-- | Convert a <a>Mnemonic</a> back to an <a>Entropy</a>.
mnemonicToEntropy :: Mnemonic mw -> Entropy (EntropySize mw)

-- | Generate Entropy of a given size using a cryptographically secure
--   random seed.
--   
--   <b>example:</b>
--   
--   <pre>
--   &gt;&gt;&gt; genEntropy @128
--   Entropy {} :: Entropy 128
--   </pre>
genEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => IO (Entropy ent)

-- | Smart-constructor for the <a>Entropy</a>. Make sure the
--   <tt>ByteString</tt> comes from a highly random source or use
--   <a>genEntropy</a>.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkEntropy @160 bytes
--   Entropy {} :: Entropy 160
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkEntropy (entropyToBytes ent) == Right ent
--   </pre>
mkEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => ScrubbedBytes -> Either (EntropyError csz) (Entropy ent)

-- | Convert <a>Entropy</a> to plain bytes.
entropyToBytes :: Entropy n -> ScrubbedBytes

-- | Convert an Entropy to a corresponding Mnemonic Sentence. Since
--   <a>Entropy</a> and <a>Mnemonic</a> can only be created through
--   smart-constructors, this function cannot fail and is total.
entropyToMnemonic :: forall mw ent csz. (ValidMnemonicSentence mw, ValidEntropySize ent, ValidChecksumSize ent csz, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Entropy ent -> Mnemonic mw
instance GHC.Show.Show (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Show.Show (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Show.Show (Cardano.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Crypto.Encoding.BIP39.EntropyError czs)
instance GHC.Classes.Eq Crypto.Encoding.BIP39.MnemonicWordsError
instance GHC.Classes.Eq Crypto.Encoding.BIP39.Dictionary.DictionaryError
instance GHC.Show.Show Cardano.Mnemonic.SomeMnemonic
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz, Cardano.Mnemonic.MkSomeMnemonic rest, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.MkSomeMnemonic (mw : rest)
instance Cardano.Mnemonic.NatVals '[]
instance (GHC.TypeNats.KnownNat n, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.NatVals (n : rest)
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz) => Cardano.Mnemonic.MkSomeMnemonic '[mw]
instance GHC.Classes.Eq Cardano.Mnemonic.SomeMnemonic
instance GHC.TypeNats.KnownNat csz => GHC.Exception.Type.Exception (Cardano.Mnemonic.MnemonicException csz)

module Cardano.Address.Derivation

-- | A derivation index, with phantom-types to disambiguate derivation
--   type.
--   
--   <pre>
--   let accountIx = Index 'Hardened 'AccountK
--   let addressIx = Index 'Soft 'AddressK
--   </pre>
data Index (derivationType :: DerivationType) (depth :: Depth)

-- | Key Depth in the derivation path, according to BIP-0039 / BIP-0044
--   
--   <pre>
--   root | purpose' | cointype' | account' | change | address@
--   0th      1st         2nd        3rd        4th      5th
--   </pre>
--   
--   We do not manipulate purpose, cointype and change paths directly, so
--   there are no constructors for these.
data Depth
RootK :: Depth
AccountK :: Depth
AddressK :: Depth
StakingK :: Depth

-- | Type of derivation that should be used with the given indexes.
--   
--   In theory, we should only consider two derivation types: soft and
--   hard.
--   
--   However, historically, addresses in Cardano used to be generated
--   across both the soft and the hard domain. We therefore introduce a
--   <a>WholeDomain</a> derivation type that is the exact union of
--   <a>Hardened</a> and <a>Soft</a>.
data DerivationType
Hardened :: DerivationType
Soft :: DerivationType
WholeDomain :: DerivationType

-- | Marker for addresses type engaged. We want to handle three cases here.
--   The first two are pertinent to UTxO accounting and the last one
--   handles rewards from participation in staking. (a) external chain is
--   used for addresses that are part of the <tt>advertised</tt> targets of
--   a given transaction (b) internal change is for addresses used to
--   handle the change of a the transaction within a given wallet
data AccountingStyle
UTxOExternal :: AccountingStyle
UTxOInternal :: AccountingStyle

-- | Abstract interface for constructing a <i>Master Key</i>.
class GenMasterKey (key :: Depth -> * -> *) where {
    type family SecondFactor key :: *;
}

-- | Generate a root key from a corresponding mnemonic.
genMasterKeyFromMnemonic :: GenMasterKey key => SomeMnemonic -> SecondFactor key -> key  'RootK XPrv

-- | Generate a root key from a corresponding root <a>XPrv</a>
genMasterKeyFromXPrv :: GenMasterKey key => XPrv -> key  'RootK XPrv

-- | An interface for doing hard derivations from the root private key,
--   <i>Master Key</i>
class HardDerivation (key :: Depth -> * -> *) where {
    type family AccountIndexDerivationType key :: DerivationType;
    type family AddressIndexDerivationType key :: DerivationType;
    type family WithAccountStyle key :: *;
}

-- | Derives account private key from the given root private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
deriveAccountPrivateKey :: HardDerivation key => key  'RootK XPrv -> Index (AccountIndexDerivationType key)  'AccountK -> key  'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
deriveAddressPrivateKey :: HardDerivation key => key  'AccountK XPrv -> WithAccountStyle key -> Index (AddressIndexDerivationType key)  'AddressK -> key  'AddressK XPrv

-- | An interface for doing soft derivations from an account public key
class HardDerivation key => SoftDerivation (key :: Depth -> * -> *)

-- | Derives address public key from the given account public key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   This is the preferred way of deriving new sequential address public
--   keys.
deriveAddressPublicKey :: SoftDerivation key => key  'AccountK XPub -> AccountingStyle -> Index  'Soft  'AddressK -> key  'AddressK XPub

-- | An opaque type representing an extended public key.
type XPub = XPub

-- | Construct an <a>XPub</a> from raw <a>ByteString</a>
xpubFromBytes :: ByteString -> Maybe XPub

-- | Convert an <a>XPub</a> to a raw <a>ByteString</a> (both public key and
--   chain code)
xpubToBytes :: XPub -> ByteString

-- | Get a public key <a>ByteString</a> from <a>XPub</a>
getPublicKey :: XPub -> ByteString

-- | Get a chain code <a>ByteString</a> from <a>XPub</a>
getChainCode :: XPub -> ByteString

-- | An opaque type representing an extended private key.
type XPrv = XPrv

-- | Construct an <a>XPrv</a> from raw <a>ByteString</a>.
xprvFromBytes :: ByteString -> Maybe XPrv

-- | Convert an <a>XPrv</a> to a raw <a>ByteString</a>.
xprvToBytes :: XPrv -> ByteString

-- | Derive the <a>XPub</a> from a corresponding <a>XPrv</a>.
toXPub :: HasCallStack => XPrv -> XPub

-- | An opaque type representing a signature made from an <a>XPrv</a>
type XSignature = XSignature

-- | Produce a signature of the given <tt>msg</tt> from an <a>XPrv</a>.
sign :: ByteArrayAccess msg => XPrv -> msg -> XSignature

-- | Verify the <a>XSignature</a> of a <tt>msg</tt> with the <a>XPub</a>
--   associated with the <a>XPrv</a> used for signing.
verify :: ByteArrayAccess msg => XPub -> msg -> XSignature -> Bool
instance GHC.Classes.Ord (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Classes.Eq (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Show.Show (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Generics.Generic (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Enum.Bounded Cardano.Address.Derivation.AccountingStyle
instance GHC.Classes.Ord Cardano.Address.Derivation.AccountingStyle
instance GHC.Classes.Eq Cardano.Address.Derivation.AccountingStyle
instance GHC.Show.Show Cardano.Address.Derivation.AccountingStyle
instance GHC.Generics.Generic Cardano.Address.Derivation.AccountingStyle
instance Control.DeepSeq.NFData (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Hardened depth)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Soft depth)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.WholeDomain depth)
instance GHC.Enum.Enum (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Hardened depth)
instance GHC.Enum.Enum (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Soft depth)
instance GHC.Enum.Enum (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.WholeDomain depth)
instance Formatting.Buildable.Buildable (Cardano.Address.Derivation.Index derivationType depth)
instance Control.DeepSeq.NFData Cardano.Address.Derivation.AccountingStyle
instance GHC.Enum.Enum Cardano.Address.Derivation.AccountingStyle

module Cardano.Address

-- | An <a>Address</a> type representing <tt>Cardano</tt> addresses.
--   Internals are irrevelant to the user.
data Address

-- | Encoding of addresses for certain key types and backend targets.
class HasNetworkDiscriminant key => PaymentAddress key

-- | Convert a public key to a payment <a>Address</a> valid for the given
--   network discrimination.
paymentAddress :: PaymentAddress key => NetworkDiscriminant key -> key  'AddressK XPub -> Address

-- | Encoding of delegation addresses for certain key types and backend
--   targets.
class PaymentAddress key => DelegationAddress key

-- | Convert a public key and a staking key to a delegation <a>Address</a>
--   valid for the given network discrimination. Funds sent to this address
--   will be delegated according to the delegation settings attached to the
--   delegation key.
delegationAddress :: DelegationAddress key => NetworkDiscriminant key -> key  'AddressK XPub -> key  'StakingK XPub -> Address

-- | Encode an <a>Address</a> to a base58 <a>Text</a>.
base58 :: Address -> Text

-- | Decode a base58-encoded <a>Text</a> into an <a>Address</a>
fromBase58 :: Text -> Maybe Address

-- | Encode an <a>Address</a> to bech32 <a>Text</a>, using <tt>addr</tt> as
--   a human readable prefix.
bech32 :: Address -> Text

-- | Decode a bech32-encoded <a>Text</a> into an <a>Address</a>
fromBech32 :: Text -> Maybe Address
instance GHC.Classes.Eq Cardano.Address.AddressDiscrimination
instance GHC.Show.Show Cardano.Address.AddressDiscrimination
instance GHC.Generics.Generic Cardano.Address.AddressDiscrimination
instance GHC.Classes.Eq Cardano.Address.NetworkTag
instance GHC.Show.Show Cardano.Address.NetworkTag
instance GHC.Generics.Generic Cardano.Address.NetworkTag
instance GHC.Classes.Ord Cardano.Address.Address
instance GHC.Classes.Eq Cardano.Address.Address
instance GHC.Show.Show Cardano.Address.Address
instance GHC.Generics.Generic Cardano.Address.Address
instance Control.DeepSeq.NFData Cardano.Address.AddressDiscrimination
instance Control.DeepSeq.NFData Cardano.Address.NetworkTag
instance Control.DeepSeq.NFData Cardano.Address.Address


module Cardano.Address.Style.Shelley

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = Shelley 'RootK XPrv
--   let accountPubKey  = Shelley 'AccountK XPub
--   let addressPubKey  = Shelley 'AddressK XPub
--   </pre>
data Shelley (depth :: Depth) key

-- | Derive a staking key for a corresponding <a>AccountK</a>. Note that
--   wallet software are by convention only using one staking key per
--   account, and always the first account (with index 0').
--   
--   Deriving staking keys for something else than the initial account is
--   not recommended and can lead to incompatibility with existing wallet
--   softwares (Daedalus, Yoroi, Adalite...).
deriveStakingPrivateKey :: Shelley  'AccountK XPrv -> Shelley  'StakingK XPrv

-- | Error reported from trying to create a network discriminant from
--   number
newtype MkNetworkDiscriminantError

-- | Wrong network tag.
ErrWrongNetworkTag :: Word8 -> MkNetworkDiscriminantError

-- | Construct <a>NetworkDiscriminant</a> for Cardano <a>Shelley</a> from a
--   number. If the number is invalid, ie., not between 0 and 15, then
--   <a>MkNetworkDiscriminantError</a> is thrown.
mkNetworkDiscriminant :: Word8 -> Either MkNetworkDiscriminantError (NetworkDiscriminant Shelley)

-- | Extract the raw <a>XPrv</a> or <a>XPub</a> wrapped by this type.
getKey :: Shelley depth key -> key

-- | Unsafe backdoor for constructing an <a>Shelley</a> key from a raw
--   <a>XPrv</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPrv :: XPrv -> Shelley depth XPrv

-- | The minimum seed length for <a>genMasterKeyFromMnemonic</a>.
minSeedLengthBytes :: Int

-- | Size, in bytes, of a hash of public key (without the corresponding
--   chain code)
publicKeyHashSize :: Int
instance GHC.Show.Show Cardano.Address.Style.Shelley.MkNetworkDiscriminantError
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.MkNetworkDiscriminantError
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Address.Style.Shelley.Shelley depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Address.Style.Shelley.Shelley depth key)
instance GHC.Generics.Generic (Cardano.Address.Style.Shelley.Shelley depth key)
instance GHC.Base.Functor (Cardano.Address.Style.Shelley.Shelley depth)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Address.Style.Shelley.Shelley depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Shelley.Shelley
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Shelley.Shelley
instance Cardano.Address.Derivation.SoftDerivation Cardano.Address.Style.Shelley.Shelley
instance Cardano.Address.HasNetworkDiscriminant Cardano.Address.Style.Shelley.Shelley
instance Cardano.Address.PaymentAddress Cardano.Address.Style.Shelley.Shelley
instance Cardano.Address.DelegationAddress Cardano.Address.Style.Shelley.Shelley


module Cardano.Address.Style.Byron

-- | Material for deriving HD random scheme keys, which can be used for
--   making addresses.

-- | <i>Deprecated: see Cardano.Address.Style.Icarus</i>
data Byron (depth :: Depth) key

-- | The hierarchical derivation indices for a given level/depth.

-- | <i>Deprecated: see Cardano.Address.Style.Icarus</i>
type family DerivationPath (depth :: Depth) :: *

-- | Used for encryption of the derivation path payload within an address.

-- | <i>Deprecated: see Cardano.Address.Style.Icarus</i>
payloadPassphrase :: Byron depth key -> ScrubbedBytes

-- | The address derivation indices for the level of this key.

-- | <i>Deprecated: see Cardano.Address.Style.Icarus</i>
derivationPath :: Byron depth key -> DerivationPath depth

-- | The raw private or public key.

-- | <i>Deprecated: see Cardano.Address.Style.Icarus</i>
getKey :: Byron depth key -> key

-- | <a>NetworkDiscriminant</a> for Cardano MainNet &amp; Byron
byronMainnet :: NetworkDiscriminant Byron

-- | <a>NetworkDiscriminant</a> for Cardano Staging &amp; Byron
byronStaging :: NetworkDiscriminant Byron

-- | <a>NetworkDiscriminant</a> for Cardano TestNet &amp; Byron
byronTestnet :: NetworkDiscriminant Byron

-- | Backdoor for generating a new key from a raw XPrv.
--   
--   Note that the <tt>depth</tt> is left open so that the caller gets to
--   decide what type of key this is. This is mostly for testing, in
--   practice, seeds are used to represent root keys, and one should
--   <a>genMasterKeyFromXPrv</a>
--   
--   The first argument is a type-family <a>DerivationPath</a> and its type
--   depends on the <tt>depth</tt> of the key.
--   
--   <b>examples:</b>
--   
--   <pre>
--   &gt;&gt;&gt; liftXPrv () prv
--   _ :: Byron RootK XPrv
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftXPrv minBound prv
--   _ :: Byron AccountK XPrv
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftXPrv (minBound, minBound) prv
--   _ :: Byron AddressK XPrv
--   </pre>

-- | <i>Deprecated: see Cardano.Address.Style.Icarus</i>
liftXPrv :: DerivationPath depth -> XPrv -> Byron depth XPrv
instance GHC.Generics.Generic (Cardano.Address.Style.Byron.Byron depth key)
instance (GHC.Show.Show key, GHC.Show.Show (Cardano.Address.Style.Byron.DerivationPath depth)) => GHC.Show.Show (Cardano.Address.Style.Byron.Byron depth key)
instance (GHC.Classes.Eq key, GHC.Classes.Eq (Cardano.Address.Style.Byron.DerivationPath depth)) => GHC.Classes.Eq (Cardano.Address.Style.Byron.Byron depth key)
instance GHC.Base.Functor (Cardano.Address.Style.Byron.Byron depth)
instance (Control.DeepSeq.NFData key, Control.DeepSeq.NFData (Cardano.Address.Style.Byron.DerivationPath depth)) => Control.DeepSeq.NFData (Cardano.Address.Style.Byron.Byron depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Byron.Byron
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Byron.Byron
instance Cardano.Address.HasNetworkDiscriminant Cardano.Address.Style.Byron.Byron
instance Cardano.Address.PaymentAddress Cardano.Address.Style.Byron.Byron


module Cardano.Address.Style.Icarus

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = Icarus 'RootK XPrv
--   let accountPubKey  = Icarus 'AccountK XPub
--   let addressPubKey  = Icarus 'AddressK XPub
--   </pre>
data Icarus (depth :: Depth) key

-- | Extract the raw <a>XPrv</a> or <tt>XPub</tt> wrapped by this type.
getKey :: Icarus depth key -> key

-- | <a>NetworkDiscriminant</a> for Cardano MainNet &amp; <a>Icarus</a>
icarusMainnet :: NetworkDiscriminant Icarus

-- | <a>NetworkDiscriminant</a> for Cardano Staging &amp; <a>Icarus</a>
icarusStaging :: NetworkDiscriminant Icarus

-- | <a>NetworkDiscriminant</a> for Cardano TestNet &amp; <a>Icarus</a>
icarusTestnet :: NetworkDiscriminant Icarus

-- | Unsafe backdoor for constructing an <a>Icarus</a> key from a raw
--   <a>XPrv</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPrv :: XPrv -> Icarus depth XPrv
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Generics.Generic (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Base.Functor (Cardano.Address.Style.Icarus.Icarus depth)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Address.Style.Icarus.Icarus depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.Derivation.SoftDerivation Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.HasNetworkDiscriminant Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.PaymentAddress Cardano.Address.Style.Icarus.Icarus
