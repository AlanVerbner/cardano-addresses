-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library utilities for mnemonic generation and address derivation.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/cardano-addresses</a>
@package cardano-addresses
@version 1.0.0

module Cardano.Mnemonic

-- | Generate Entropy of a given size using a cryptographically secure
--   random seed.
--   
--   <b>example:</b>
--   
--   <pre>
--   &gt;&gt;&gt; genEntropy @128
--   Entropy {} :: Entropy 128
--   </pre>
genEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => IO (Entropy ent)

-- | Smart-constructor for the <a>Entropy</a>. Make sure the
--   <tt>ByteString</tt> comes from a highly random source or use
--   <a>genEntropy</a>.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkEntropy @160 bytes
--   Entropy {} :: Entropy 160
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkEntropy (entropyToBytes ent) == Right ent
--   </pre>
mkEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => ScrubbedBytes -> Either (EntropyError csz) (Entropy ent)

-- | Convert <a>Entropy</a> to plain bytes.
entropyToBytes :: Entropy n -> ScrubbedBytes

-- | Convert an Entropy to a corresponding Mnemonic Sentence. Since
--   <a>Entropy</a> and <a>Mnemonic</a> can only be created through
--   smart-constructors, this function cannot fail and is total.
entropyToMnemonic :: forall mw ent csz. (ValidMnemonicSentence mw, ValidEntropySize ent, ValidChecksumSize ent csz, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Entropy ent -> Mnemonic mw

-- | Smart-constructor for <a>Mnemonic</a>. Requires a type application to
--   disambiguate the mnemonic size.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkMnemonic @15 sentence
--   Mnemonic {} :: Mnemonic 15
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkMnemonic (mnemonicToText mnemonic) == Right mnemonic
--   </pre>
mkMnemonic :: forall (mw :: Nat) (ent :: Nat) csz. (ConsistentEntropy ent mw csz, EntropySize mw ~ ent) => [Text] -> Either (MkMnemonicError csz) (Mnemonic mw)

-- | This wraps errors from <a>Cardano.Encoding.BIP39</a>
data MkMnemonicError csz

-- | Wrong number of words in mnemonic.
ErrMnemonicWords :: MnemonicWordsError -> MkMnemonicError csz

-- | Invalid entropy length or checksum.
ErrEntropy :: EntropyError csz -> MkMnemonicError csz

-- | Invalid word in mnemonic.
ErrDictionary :: DictionaryError -> MkMnemonicError csz

-- | Convert a <a>Mnemonic</a> to a sentence of English mnemonic words.
mnemonicToText :: Mnemonic mw -> [Text]

-- | Convert a <a>Mnemonic</a> back to an <a>Entropy</a>.
mnemonicToEntropy :: Mnemonic mw -> Entropy (EntropySize mw)

-- | Ease the manipulation of <a>Mnemonic</a> by encapsulating the type
--   constraints inside a constructor. This is particularly useful for
--   functions which do not require anything but a valid <a>Mnemonic</a>
--   without any particular pre-condition on the size of the
--   <a>Mnemonic</a> itself.
data SomeMnemonic
[SomeMnemonic] :: forall mw. KnownNat mw => Mnemonic mw -> SomeMnemonic

-- | Construct a mnemonic from a list of words. This function is
--   particularly useful when the number of words is not necessarily known
--   at runtime. The function is however <i>ambiguous</i> and requires
--   thereby a type application.
--   
--   <b>examples:</b>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 12 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Left "Invalid number of words: 12 words are expected."
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 9, 12, 15 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Right (SomeMnemonic ...)
--   </pre>
mkSomeMnemonic :: MkSomeMnemonic sz => [Text] -> Either (MkSomeMnemonicError sz) SomeMnemonic

-- | Error reported from trying to create a passphrase from a given
--   mnemonic
newtype MkSomeMnemonicError (sz :: [Nat])
MkSomeMnemonicError :: String -> MkSomeMnemonicError
[getMkSomeMnemonicError] :: MkSomeMnemonicError -> String
instance Formatting.Buildable.Buildable (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Show.Show (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Show.Show (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Show.Show (Cardano.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Crypto.Encoding.BIP39.EntropyError czs)
instance GHC.Classes.Eq Crypto.Encoding.BIP39.MnemonicWordsError
instance GHC.Classes.Eq Crypto.Encoding.BIP39.Dictionary.DictionaryError
instance GHC.Show.Show Cardano.Mnemonic.SomeMnemonic
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz, Cardano.Mnemonic.MkSomeMnemonic rest, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.MkSomeMnemonic (mw : rest)
instance Cardano.Mnemonic.NatVals '[]
instance (GHC.TypeNats.KnownNat n, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.NatVals (n : rest)
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz) => Cardano.Mnemonic.MkSomeMnemonic '[mw]
instance GHC.Classes.Eq Cardano.Mnemonic.SomeMnemonic
instance GHC.TypeNats.KnownNat csz => GHC.Exception.Type.Exception (Cardano.Mnemonic.MnemonicException csz)
