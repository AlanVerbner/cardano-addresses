-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library utilities for mnemonic generation and address derivation.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/cardano-addresses</a>
@package cardano-addresses
@version 1.0.0

module Cardano.AddressDerivation

-- | Abstract interface for constructing a <i>Master Key</i>.
class GenMasterKey (key :: Depth -> * -> *) where {
    type family GenMasterKeyFrom key :: *;
}

-- | Generate a root key from a corresponding seed.
genMasterKey :: GenMasterKey key => GenMasterKeyFrom key -> ScrubbedBytes -> key  'RootK XPrv

-- | An interface for doing hard derivations from the root private key,
--   <i>Master Key</i>
class HardDerivation (key :: Depth -> * -> *) where {
    type family AccountIndexDerivationType key :: DerivationType;
    type family AddressIndexDerivationType key :: DerivationType;
}

-- | Derives account private key from the given root private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
deriveAccountPrivateKey :: HardDerivation key => ScrubbedBytes -> key  'RootK XPrv -> Index (AccountIndexDerivationType key)  'AccountK -> key  'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
deriveAddressPrivateKey :: HardDerivation key => ScrubbedBytes -> key  'AccountK XPrv -> AccountingStyle -> Index (AddressIndexDerivationType key)  'AddressK -> key  'AddressK XPrv

-- | An interface for doing soft derivations from an account public key
class HardDerivation key => SoftDerivation (key :: Depth -> * -> *)

-- | Derives address public key from the given account public key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   This is the preferred way of deriving new sequential address public
--   keys.
deriveAddressPublicKey :: SoftDerivation key => key  'AccountK XPub -> AccountingStyle -> Index  'Soft  'AddressK -> key  'AddressK XPub

-- | A derivation index, with phantom-types to disambiguate derivation
--   type.
--   
--   <pre>
--   let accountIx = Index 'Hardened 'AccountK
--   let addressIx = Index 'Soft 'AddressK
--   </pre>
newtype Index (derivationType :: DerivationType) (level :: Depth)
Index :: Word32 -> Index
[getIndex] :: Index -> Word32

-- | Key Depth in the derivation path, according to BIP-0039 / BIP-0044
--   
--   <pre>
--   m | purpose' | cointype' | account' | change | address
--   </pre>
--   
--   We do not manipulate purpose, cointype and change paths directly, so
--   they are left out of the sum type.
data Depth
RootK :: Depth
AccountK :: Depth
AddressK :: Depth

-- | Type of derivation that should be used with the given indexes.
--   
--   In theory, we should only consider two derivation types: soft and
--   hard.
--   
--   However, historically, addresses in Cardano used to be generated
--   across the both soft and hard domain. We therefore introduce a
--   <a>WholeDomain</a> derivation type that is the exact union of
--   <a>Hardened</a> and <a>Soft</a>.
data DerivationType
Hardened :: DerivationType
Soft :: DerivationType
WholeDomain :: DerivationType

-- | Marker for addresses type engaged. We want to handle three cases here.
--   The first two are pertinent to UTxO accounting and the last one
--   handles rewards from participation in staking. (a) external chain is
--   used for addresses that are part of the <tt>advertised</tt> targets of
--   a given transaction (b) internal change is for addresses used to
--   handle the change of a the transaction within a given wallet (c) the
--   addresses for a reward (chimeric) account
data AccountingStyle
UTxOExternal :: AccountingStyle
UTxOInternal :: AccountingStyle
MutableAccount :: AccountingStyle
instance GHC.Classes.Ord (Cardano.AddressDerivation.Index derivationType level)
instance GHC.Classes.Eq (Cardano.AddressDerivation.Index derivationType level)
instance GHC.Show.Show (Cardano.AddressDerivation.Index derivationType level)
instance GHC.Generics.Generic (Cardano.AddressDerivation.Index derivationType level)
instance GHC.Enum.Bounded Cardano.AddressDerivation.AccountingStyle
instance GHC.Classes.Ord Cardano.AddressDerivation.AccountingStyle
instance GHC.Classes.Eq Cardano.AddressDerivation.AccountingStyle
instance GHC.Show.Show Cardano.AddressDerivation.AccountingStyle
instance GHC.Generics.Generic Cardano.AddressDerivation.AccountingStyle
instance Control.DeepSeq.NFData (Cardano.AddressDerivation.Index derivationType level)
instance GHC.Enum.Bounded (Cardano.AddressDerivation.Index 'Cardano.AddressDerivation.Hardened level)
instance GHC.Enum.Bounded (Cardano.AddressDerivation.Index 'Cardano.AddressDerivation.Soft level)
instance GHC.Enum.Bounded (Cardano.AddressDerivation.Index 'Cardano.AddressDerivation.WholeDomain level)
instance GHC.Enum.Enum (Cardano.AddressDerivation.Index 'Cardano.AddressDerivation.Hardened level)
instance GHC.Enum.Enum (Cardano.AddressDerivation.Index 'Cardano.AddressDerivation.Soft level)
instance GHC.Enum.Enum (Cardano.AddressDerivation.Index 'Cardano.AddressDerivation.WholeDomain level)
instance Formatting.Buildable.Buildable (Cardano.AddressDerivation.Index derivationType level)
instance Control.DeepSeq.NFData Cardano.AddressDerivation.AccountingStyle
instance GHC.Enum.Enum Cardano.AddressDerivation.AccountingStyle

module Cardano.Mnemonic

-- | Generate Entropy of a given size using a cryptographically secure
--   random seed.
--   
--   <b>example:</b>
--   
--   <pre>
--   &gt;&gt;&gt; genEntropy @128
--   Entropy {} :: Entropy 128
--   </pre>
genEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => IO (Entropy ent)

-- | Smart-constructor for the <a>Entropy</a>. Make sure the
--   <tt>ByteString</tt> comes from a highly random source or use
--   <a>genEntropy</a>.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkEntropy @160 bytes
--   Entropy {} :: Entropy 160
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkEntropy (entropyToBytes ent) == Right ent
--   </pre>
mkEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => ScrubbedBytes -> Either (EntropyError csz) (Entropy ent)

-- | Convert <a>Entropy</a> to plain bytes.
entropyToBytes :: Entropy n -> ScrubbedBytes

-- | Convert an Entropy to a corresponding Mnemonic Sentence. Since
--   <a>Entropy</a> and <a>Mnemonic</a> can only be created through
--   smart-constructors, this function cannot fail and is total.
entropyToMnemonic :: forall mw ent csz. (ValidMnemonicSentence mw, ValidEntropySize ent, ValidChecksumSize ent csz, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Entropy ent -> Mnemonic mw

-- | Smart-constructor for <a>Mnemonic</a>. Requires a type application to
--   disambiguate the mnemonic size.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkMnemonic @15 sentence
--   Mnemonic {} :: Mnemonic 15
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkMnemonic (mnemonicToText mnemonic) == Right mnemonic
--   </pre>
mkMnemonic :: forall (mw :: Nat) (ent :: Nat) csz. (ConsistentEntropy ent mw csz, EntropySize mw ~ ent) => [Text] -> Either (MkMnemonicError csz) (Mnemonic mw)

-- | This wraps errors from <a>Cardano.Encoding.BIP39</a>
data MkMnemonicError csz

-- | Wrong number of words in mnemonic.
ErrMnemonicWords :: MnemonicWordsError -> MkMnemonicError csz

-- | Invalid entropy length or checksum.
ErrEntropy :: EntropyError csz -> MkMnemonicError csz

-- | Invalid word in mnemonic.
ErrDictionary :: DictionaryError -> MkMnemonicError csz

-- | Convert a <a>Mnemonic</a> to a sentence of English mnemonic words.
mnemonicToText :: Mnemonic mw -> [Text]

-- | Convert a <a>Mnemonic</a> back to an <a>Entropy</a>.
mnemonicToEntropy :: Mnemonic mw -> Entropy (EntropySize mw)

-- | Ease the manipulation of <a>Mnemonic</a> by encapsulating the type
--   constraints inside a constructor. This is particularly useful for
--   functions which do not require anything but a valid <a>Mnemonic</a>
--   without any particular pre-condition on the size of the
--   <a>Mnemonic</a> itself.
data SomeMnemonic
[SomeMnemonic] :: forall mw. KnownNat mw => Mnemonic mw -> SomeMnemonic

-- | Construct a mnemonic from a list of words. This function is
--   particularly useful when the number of words is not necessarily known
--   at runtime. The function is however <i>ambiguous</i> and requires
--   thereby a type application.
--   
--   <b>examples:</b>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 12 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Left "Invalid number of words: 12 words are expected."
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 9, 12, 15 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Right (SomeMnemonic ...)
--   </pre>
mkSomeMnemonic :: MkSomeMnemonic sz => [Text] -> Either (MkSomeMnemonicError sz) SomeMnemonic

-- | Error reported from trying to create a passphrase from a given
--   mnemonic
newtype MkSomeMnemonicError (sz :: [Nat])
MkSomeMnemonicError :: String -> MkSomeMnemonicError
[getMkSomeMnemonicError] :: MkSomeMnemonicError -> String
instance Formatting.Buildable.Buildable (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Show.Show (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Show.Show (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Show.Show (Cardano.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Crypto.Encoding.BIP39.EntropyError czs)
instance GHC.Classes.Eq Crypto.Encoding.BIP39.MnemonicWordsError
instance GHC.Classes.Eq Crypto.Encoding.BIP39.Dictionary.DictionaryError
instance GHC.Show.Show Cardano.Mnemonic.SomeMnemonic
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz, Cardano.Mnemonic.MkSomeMnemonic rest, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.MkSomeMnemonic (mw : rest)
instance Cardano.Mnemonic.NatVals '[]
instance (GHC.TypeNats.KnownNat n, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.NatVals (n : rest)
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz) => Cardano.Mnemonic.MkSomeMnemonic '[mw]
instance GHC.Classes.Eq Cardano.Mnemonic.SomeMnemonic
instance GHC.TypeNats.KnownNat csz => GHC.Exception.Type.Exception (Cardano.Mnemonic.MnemonicException csz)


-- | Implementation of address derivation for the random scheme, as
--   implemented by the Icarus wallet.
--   
--   For full documentation of the key derivation schemes, see the
--   <a>Cardano.Crypto.Wallet</a> module, and the implementation in
--   <a>cardano-crypto</a>.
module Cardano.AddressDerivation.Icarus

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = Icarus 'RootK XPrv
--   let accountPubKey = Icarus 'AccountK XPub
--   let addressPubKey = Icarus 'AddressK XPub
--   </pre>
newtype Icarus (depth :: Depth) key
Icarus :: key -> Icarus key
[getKey] :: Icarus key -> key

-- | Hardware Ledger devices generates keys from mnemonic using a different
--   approach (different from the rest of Cardano).
--   
--   It is a combination of:
--   
--   <ul>
--   <li><a>SLIP 0010</a></li>
--   <li><a>BIP 0032</a></li>
--   <li><a>BIP 0039</a></li>
--   <li><a>RFC 8032</a></li>
--   <li>What seems to be arbitrary changes from Ledger regarding the
--   calculation of the initial chain code and generation of the root
--   private key.</li>
--   </ul>
unsafeGenerateKeyFromHardwareLedger :: SomeMnemonic -> ScrubbedBytes -> Icarus  'RootK XPrv

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <tt>generateKeyFromSeed</tt>.
unsafeGenerateKeyFromSeed :: SomeMnemonic -> ScrubbedBytes -> Icarus depth XPrv

-- | The minimum seed length for <tt>generateKeyFromSeed</tt> and
--   <a>unsafeGenerateKeyFromSeed</a>.
minSeedLengthBytes :: Int
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.AddressDerivation.Icarus.Icarus depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.AddressDerivation.Icarus.Icarus depth key)
instance GHC.Generics.Generic (Cardano.AddressDerivation.Icarus.Icarus depth key)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.AddressDerivation.Icarus.Icarus depth key)
instance Cardano.AddressDerivation.GenMasterKey Cardano.AddressDerivation.Icarus.Icarus
instance Cardano.AddressDerivation.HardDerivation Cardano.AddressDerivation.Icarus.Icarus
instance Cardano.AddressDerivation.SoftDerivation Cardano.AddressDerivation.Icarus.Icarus


-- | Implementation of address derivation for the random scheme, as
--   implemented by the legacy Cardano wallets.
--   
--   For full documentation of the key derivation schemes, see the
--   <a>Cardano.Crypto.Wallet</a> module, and the implementation in
--   <a>cardano-crypto</a>.
module Cardano.AddressDerivation.Byron

-- | Material for deriving HD random scheme keys, which can be used for
--   making addresses.
data Byron (depth :: Depth) key
Byron :: key -> DerivationPath depth -> ScrubbedBytes -> Byron key

-- | The raw private or public key.
[getKey] :: Byron key -> key

-- | The address derivation indices for the level of this key.
[derivationPath] :: Byron key -> DerivationPath depth

-- | Used for encryption of payload containing address derivation path.
[payloadPassphrase] :: Byron key -> ScrubbedBytes

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: DerivationPath depth -> SomeMnemonic -> ScrubbedBytes -> Byron depth XPrv

-- | The amount of entropy carried by a BIP-39 12-word mnemonic is 16
--   bytes.
minSeedLengthBytes :: Int
mkByronKeyFromMasterKey :: XPrv -> Byron  'RootK XPrv
unsafeMkByronKeyFromMasterKey :: DerivationPath depth -> XPrv -> Byron depth XPrv
instance GHC.Generics.Generic (Cardano.AddressDerivation.Byron.Byron depth key)
instance (GHC.Show.Show key, GHC.Show.Show (Cardano.AddressDerivation.Byron.DerivationPath depth)) => GHC.Show.Show (Cardano.AddressDerivation.Byron.Byron depth key)
instance (GHC.Classes.Eq key, GHC.Classes.Eq (Cardano.AddressDerivation.Byron.DerivationPath depth)) => GHC.Classes.Eq (Cardano.AddressDerivation.Byron.Byron depth key)
instance (Control.DeepSeq.NFData key, Control.DeepSeq.NFData (Cardano.AddressDerivation.Byron.DerivationPath depth)) => Control.DeepSeq.NFData (Cardano.AddressDerivation.Byron.Byron depth key)
instance Cardano.AddressDerivation.GenMasterKey Cardano.AddressDerivation.Byron.Byron
instance Cardano.AddressDerivation.HardDerivation Cardano.AddressDerivation.Byron.Byron
