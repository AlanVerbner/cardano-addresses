-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library utilities for mnemonic generation and address derivation.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/cardano-addresses</a>
@package cardano-addresses
@version 1.0.0

module Cardano.Address.Derivation

-- | Abstract interface for constructing a <i>Master Key</i>.
class GenMasterKey (key :: Depth -> * -> *) where {
    type family GenMasterKeyFrom key :: *;
}

-- | Generate a root key from a corresponding seed.
genMasterKey :: GenMasterKey key => GenMasterKeyFrom key -> ScrubbedBytes -> key  'RootK XPrv

-- | An interface for doing hard derivations from the root private key,
--   <i>Master Key</i>
class HardDerivation (key :: Depth -> * -> *) where {
    type family AccountIndexDerivationType key :: DerivationType;
    type family AddressIndexDerivationType key :: DerivationType;
}

-- | Derives account private key from the given root private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
deriveAccountPrivateKey :: HardDerivation key => ScrubbedBytes -> key  'RootK XPrv -> Index (AccountIndexDerivationType key)  'AccountK -> key  'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
deriveAddressPrivateKey :: HardDerivation key => ScrubbedBytes -> key  'AccountK XPrv -> AccountingStyle -> Index (AddressIndexDerivationType key)  'AddressK -> key  'AddressK XPrv

-- | An interface for doing soft derivations from an account public key
class HardDerivation key => SoftDerivation (key :: Depth -> * -> *)

-- | Derives address public key from the given account public key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   This is the preferred way of deriving new sequential address public
--   keys.
deriveAddressPublicKey :: SoftDerivation key => key  'AccountK XPub -> AccountingStyle -> Index  'Soft  'AddressK -> key  'AddressK XPub

-- | A derivation index, with phantom-types to disambiguate derivation
--   type.
--   
--   <pre>
--   let accountIx = Index 'Hardened 'AccountK
--   let addressIx = Index 'Soft 'AddressK
--   </pre>
newtype Index (derivationType :: DerivationType) (level :: Depth)
Index :: Word32 -> Index
[getIndex] :: Index -> Word32

-- | Key Depth in the derivation path, according to BIP-0039 / BIP-0044
--   
--   <pre>
--   m | purpose' | cointype' | account' | change | address
--   </pre>
--   
--   We do not manipulate purpose, cointype and change paths directly, so
--   they are left out of the sum type.
data Depth
RootK :: Depth
AccountK :: Depth
AddressK :: Depth

-- | Type of derivation that should be used with the given indexes.
--   
--   In theory, we should only consider two derivation types: soft and
--   hard.
--   
--   However, historically, addresses in Cardano used to be generated
--   across the both soft and hard domain. We therefore introduce a
--   <a>WholeDomain</a> derivation type that is the exact union of
--   <a>Hardened</a> and <a>Soft</a>.
data DerivationType
Hardened :: DerivationType
Soft :: DerivationType
WholeDomain :: DerivationType

-- | Marker for addresses type engaged. We want to handle three cases here.
--   The first two are pertinent to UTxO accounting and the last one
--   handles rewards from participation in staking. (a) external chain is
--   used for addresses that are part of the <tt>advertised</tt> targets of
--   a given transaction (b) internal change is for addresses used to
--   handle the change of a the transaction within a given wallet (c) the
--   addresses for a reward (chimeric) account
data AccountingStyle
UTxOExternal :: AccountingStyle
UTxOInternal :: AccountingStyle
MutableAccount :: AccountingStyle
instance GHC.Classes.Ord (Cardano.Address.Derivation.Index derivationType level)
instance GHC.Classes.Eq (Cardano.Address.Derivation.Index derivationType level)
instance GHC.Show.Show (Cardano.Address.Derivation.Index derivationType level)
instance GHC.Generics.Generic (Cardano.Address.Derivation.Index derivationType level)
instance GHC.Enum.Bounded Cardano.Address.Derivation.AccountingStyle
instance GHC.Classes.Ord Cardano.Address.Derivation.AccountingStyle
instance GHC.Classes.Eq Cardano.Address.Derivation.AccountingStyle
instance GHC.Show.Show Cardano.Address.Derivation.AccountingStyle
instance GHC.Generics.Generic Cardano.Address.Derivation.AccountingStyle
instance Control.DeepSeq.NFData (Cardano.Address.Derivation.Index derivationType level)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Hardened level)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Soft level)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.WholeDomain level)
instance GHC.Enum.Enum (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Hardened level)
instance GHC.Enum.Enum (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Soft level)
instance GHC.Enum.Enum (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.WholeDomain level)
instance Formatting.Buildable.Buildable (Cardano.Address.Derivation.Index derivationType level)
instance Control.DeepSeq.NFData Cardano.Address.Derivation.AccountingStyle
instance GHC.Enum.Enum Cardano.Address.Derivation.AccountingStyle

module Cardano.Address

-- | Address is mere wrapper around a ByteString and represents an encoded
--   address.
newtype Address
Address :: ByteString -> Address
[unAddress] :: Address -> ByteString

-- | Encoding of addresses for certain key types and backend targets.
class PaymentAddress key

-- | Convert a public key to a payment <a>Address</a> valid for the given
--   network discrimination.
--   
--   Note that <a>paymentAddress</a> is ambiguous and requires therefore a
--   type application.
paymentAddress :: PaymentAddress key => NetworkDiscriminant -> key  'AddressK XPub -> Address

-- | Encode an address to base58.
base58 :: Address -> Text

-- | Encode an address to bech32, using <tt>addr</tt> as a human readable
--   prefix.
bech32 :: Address -> Text

-- | Available network options.
data NetworkDiscriminant
RequiresNoMagic :: NetworkDiscriminant
RequiresMagic :: ProtocolMagic -> NetworkDiscriminant

-- | Required network discrimination settings for mainnet
mainnetDiscriminant :: NetworkDiscriminant

-- | Required network discrimination settings for staging
stagingDiscriminant :: NetworkDiscriminant

-- | Required network discrimination settings for testnet
testnetDiscriminant :: NetworkDiscriminant

-- | Magic constant associated to a given network. This is mainly use in
--   two places:
--   
--   a) In <a>Address</a> payloads, to discriminate addresses between
--   networks. b) At the network-level, when doing handshake with nodes.
newtype ProtocolMagic
ProtocolMagic :: Word32 -> ProtocolMagic
[getProtocolMagic] :: ProtocolMagic -> Word32

-- | Hard-coded <a>ProtocolMagic</a> for Cardano MainNet
mainnetMagic :: ProtocolMagic

-- | Hard-coded <a>ProtocolMagic</a> for Cardano Staging
stagingMagic :: ProtocolMagic

-- | Hard-coded <a>ProtocolMagic</a> for Cardano standard TestNet
testnetMagic :: ProtocolMagic
instance GHC.Classes.Eq Cardano.Address.NetworkDiscriminant
instance GHC.Show.Show Cardano.Address.NetworkDiscriminant
instance GHC.Generics.Generic Cardano.Address.NetworkDiscriminant
instance GHC.Classes.Eq Cardano.Address.ProtocolMagic
instance GHC.Show.Show Cardano.Address.ProtocolMagic
instance GHC.Generics.Generic Cardano.Address.ProtocolMagic
instance GHC.Classes.Ord Cardano.Address.Address
instance GHC.Classes.Eq Cardano.Address.Address
instance GHC.Show.Show Cardano.Address.Address
instance GHC.Generics.Generic Cardano.Address.Address
instance Control.DeepSeq.NFData Cardano.Address.NetworkDiscriminant
instance Control.DeepSeq.NFData Cardano.Address.ProtocolMagic
instance Control.DeepSeq.NFData Cardano.Address.Address


-- | These are (partial) CBOR decoders for Byron binary types. Note that we
--   ignore most of the block's and header's content and only retrieve the
--   pieces of information relevant to us, wallet (we do assume a trusted
--   node and therefore, we needn't to care about verifying signatures and
--   blocks themselves).
module Cardano.Codec.Cbor

-- | Encode a public key to a corresponding Cardano Address. The encoding
--   of the attributes part of an address is left out to the caller; This
--   allows for distinguishing between Sequential and Random addresses (the
--   former doesn't have any attributes to encode).
--   
--   <pre>
--   -- Old / Random Addresses
--   let encodeAddrAttributes = mempty
--        &lt;&gt; CBOR.encodeMapLen 1
--        &lt;&gt; CBOR.encodeWord8 1
--        &lt;&gt; encodeDerivationPath (hdPassphrase rootXPub) accIx addrIx
--   let addr = encodeAddress xpub encodeAddrAttributes
--   
--   -- New / Sequential Addresses
--   let encodeAddrAttributes = mempty &lt;&gt; CBOR.encodeMapLen 0
--   let addr = encodeAddress xpub encodeAddrAttributes
--   </pre>
--   
--   Note that we are passing the behavior to encode attributes as a
--   parameter here and do not handle multiple cases in
--   <a>encodeAddress</a> itself for multiple reasons:
--   
--   <ul>
--   <li>Inversion of control gives us a nicer implementation overall</li>
--   <li>Encoding attributes for Random addresses requires more context
--   than just the public key (like the wallet root id and some extra logic
--   for encoding passphrases). This is just scheme-specific and is better
--   left out of this particular function</li>
--   </ul>
encodeAddress :: XPub -> [Encoding] -> Encoding
encodeAttributes :: [Encoding] -> Encoding
encodeDerivationPathAttr :: ScrubbedBytes -> Index  'WholeDomain  'AccountK -> Index  'WholeDomain  'AddressK -> Encoding
encodeProtocolMagicAttr :: ProtocolMagic -> Encoding
decodeAddress :: Decoder s Address
decodeAddressDerivationPath :: ScrubbedBytes -> Decoder s (Maybe (Index  'WholeDomain  'AccountK, Index  'WholeDomain  'AddressK))
decodeAddressPayload :: Decoder s ByteString

-- | The attributes are pairs of numeric tags and bytes, where the bytes
--   will be CBOR-encoded stuff. This decoder does not enforce "canonicity"
--   of entries.
decodeAllAttributes :: Decoder s [(Word8, ByteString)]
decodeDerivationPathAttr :: ScrubbedBytes -> [(Word8, ByteString)] -> Decoder s (Maybe (Index  'WholeDomain  'AccountK, Index  'WholeDomain  'AddressK))
decodeProtocolMagicAttr :: Decoder s (Maybe ProtocolMagic)

-- | Shortcut for deserialising a strict <tt>Bytestring</tt> with the given
--   decoder.
deserialiseCbor :: (forall s. Decoder s a) -> ByteString -> Maybe a

-- | CBOR deserialise without error handling - handy for prototypes or
--   testing.
unsafeDeserialiseCbor :: HasCallStack => (forall s. Decoder s a) -> ByteString -> a
encodeBytes :: ByteString -> Encoding
toStrictByteString :: Encoding -> ByteString
toLazyByteString :: Encoding -> ByteString

module Cardano.Mnemonic

-- | Generate Entropy of a given size using a cryptographically secure
--   random seed.
--   
--   <b>example:</b>
--   
--   <pre>
--   &gt;&gt;&gt; genEntropy @128
--   Entropy {} :: Entropy 128
--   </pre>
genEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => IO (Entropy ent)

-- | Smart-constructor for the <a>Entropy</a>. Make sure the
--   <tt>ByteString</tt> comes from a highly random source or use
--   <a>genEntropy</a>.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkEntropy @160 bytes
--   Entropy {} :: Entropy 160
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkEntropy (entropyToBytes ent) == Right ent
--   </pre>
mkEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => ScrubbedBytes -> Either (EntropyError csz) (Entropy ent)

-- | Convert <a>Entropy</a> to plain bytes.
entropyToBytes :: Entropy n -> ScrubbedBytes

-- | Convert an Entropy to a corresponding Mnemonic Sentence. Since
--   <a>Entropy</a> and <a>Mnemonic</a> can only be created through
--   smart-constructors, this function cannot fail and is total.
entropyToMnemonic :: forall mw ent csz. (ValidMnemonicSentence mw, ValidEntropySize ent, ValidChecksumSize ent csz, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Entropy ent -> Mnemonic mw

-- | Smart-constructor for <a>Mnemonic</a>. Requires a type application to
--   disambiguate the mnemonic size.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkMnemonic @15 sentence
--   Mnemonic {} :: Mnemonic 15
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkMnemonic (mnemonicToText mnemonic) == Right mnemonic
--   </pre>
mkMnemonic :: forall (mw :: Nat) (ent :: Nat) csz. (ConsistentEntropy ent mw csz, EntropySize mw ~ ent) => [Text] -> Either (MkMnemonicError csz) (Mnemonic mw)

-- | This wraps errors from <a>Cardano.Encoding.BIP39</a>
data MkMnemonicError csz

-- | Wrong number of words in mnemonic.
ErrMnemonicWords :: MnemonicWordsError -> MkMnemonicError csz

-- | Invalid entropy length or checksum.
ErrEntropy :: EntropyError csz -> MkMnemonicError csz

-- | Invalid word in mnemonic.
ErrDictionary :: DictionaryError -> MkMnemonicError csz

-- | Convert a <a>Mnemonic</a> to a sentence of English mnemonic words.
mnemonicToText :: Mnemonic mw -> [Text]

-- | Convert a <a>Mnemonic</a> back to an <a>Entropy</a>.
mnemonicToEntropy :: Mnemonic mw -> Entropy (EntropySize mw)

-- | Ease the manipulation of <a>Mnemonic</a> by encapsulating the type
--   constraints inside a constructor. This is particularly useful for
--   functions which do not require anything but a valid <a>Mnemonic</a>
--   without any particular pre-condition on the size of the
--   <a>Mnemonic</a> itself.
data SomeMnemonic
[SomeMnemonic] :: forall mw. KnownNat mw => Mnemonic mw -> SomeMnemonic

-- | Construct a mnemonic from a list of words. This function is
--   particularly useful when the number of words is not necessarily known
--   at runtime. The function is however <i>ambiguous</i> and requires
--   thereby a type application.
--   
--   <b>examples:</b>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 12 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Left "Invalid number of words: 12 words are expected."
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 9, 12, 15 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Right (SomeMnemonic ...)
--   </pre>
mkSomeMnemonic :: MkSomeMnemonic sz => [Text] -> Either (MkSomeMnemonicError sz) SomeMnemonic

-- | Error reported from trying to create a passphrase from a given
--   mnemonic
newtype MkSomeMnemonicError (sz :: [Nat])
MkSomeMnemonicError :: String -> MkSomeMnemonicError
[getMkSomeMnemonicError] :: MkSomeMnemonicError -> String
instance Formatting.Buildable.Buildable (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Show.Show (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Show.Show (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Show.Show (Cardano.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Crypto.Encoding.BIP39.EntropyError czs)
instance GHC.Classes.Eq Crypto.Encoding.BIP39.MnemonicWordsError
instance GHC.Classes.Eq Crypto.Encoding.BIP39.Dictionary.DictionaryError
instance GHC.Show.Show Cardano.Mnemonic.SomeMnemonic
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz, Cardano.Mnemonic.MkSomeMnemonic rest, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.MkSomeMnemonic (mw : rest)
instance Cardano.Mnemonic.NatVals '[]
instance (GHC.TypeNats.KnownNat n, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.NatVals (n : rest)
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz) => Cardano.Mnemonic.MkSomeMnemonic '[mw]
instance GHC.Classes.Eq Cardano.Mnemonic.SomeMnemonic
instance GHC.TypeNats.KnownNat csz => GHC.Exception.Type.Exception (Cardano.Mnemonic.MnemonicException csz)


-- | Implementation of address derivation for the random scheme, as
--   implemented by the Icarus wallet.
--   
--   For full documentation of the key derivation schemes, see the
--   <a>Cardano.Crypto.Wallet</a> module, and the implementation in
--   <a>cardano-crypto</a>.
module Cardano.Address.Style.Icarus

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = Icarus 'RootK XPrv
--   let accountPubKey = Icarus 'AccountK XPub
--   let addressPubKey = Icarus 'AddressK XPub
--   </pre>
newtype Icarus (depth :: Depth) key
Icarus :: key -> Icarus key
[getKey] :: Icarus key -> key

-- | Hardware Ledger devices generates keys from mnemonic using a different
--   approach (different from the rest of Cardano).
--   
--   It is a combination of:
--   
--   <ul>
--   <li><a>SLIP 0010</a></li>
--   <li><a>BIP 0032</a></li>
--   <li><a>BIP 0039</a></li>
--   <li><a>RFC 8032</a></li>
--   <li>What seems to be arbitrary changes from Ledger regarding the
--   calculation of the initial chain code and generation of the root
--   private key.</li>
--   </ul>
unsafeGenerateKeyFromHardwareLedger :: SomeMnemonic -> ScrubbedBytes -> Icarus  'RootK XPrv

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <tt>generateKeyFromSeed</tt>.
unsafeGenerateKeyFromSeed :: SomeMnemonic -> ScrubbedBytes -> Icarus depth XPrv

-- | The minimum seed length for <tt>generateKeyFromSeed</tt> and
--   <a>unsafeGenerateKeyFromSeed</a>.
minSeedLengthBytes :: Int
publicKey :: Icarus depth1 XPrv -> Icarus depth2 XPub
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Generics.Generic (Cardano.Address.Style.Icarus.Icarus depth key)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Address.Style.Icarus.Icarus depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.Derivation.SoftDerivation Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.PaymentAddress Cardano.Address.Style.Icarus.Icarus


-- | Implementation of address derivation for the random scheme, as
--   implemented by the legacy Cardano wallets.
--   
--   For full documentation of the key derivation schemes, see the
--   <a>Cardano.Crypto.Wallet</a> module, and the implementation in
--   <a>cardano-crypto</a>.
module Cardano.Address.Style.Byron

-- | Material for deriving HD random scheme keys, which can be used for
--   making addresses.
data Byron (depth :: Depth) key
Byron :: key -> DerivationPath depth -> ScrubbedBytes -> Byron key

-- | The raw private or public key.
[getKey] :: Byron key -> key

-- | The address derivation indices for the level of this key.
[derivationPath] :: Byron key -> DerivationPath depth

-- | Used for encryption of payload containing address derivation path.
[payloadPassphrase] :: Byron key -> ScrubbedBytes

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: DerivationPath depth -> SomeMnemonic -> ScrubbedBytes -> Byron depth XPrv

-- | The amount of entropy carried by a BIP-39 12-word mnemonic is 16
--   bytes.
minSeedLengthBytes :: Int
mkByronKeyFromMasterKey :: XPrv -> Byron  'RootK XPrv
unsafeMkByronKeyFromMasterKey :: DerivationPath depth -> XPrv -> Byron depth XPrv
instance GHC.Generics.Generic (Cardano.Address.Style.Byron.Byron depth key)
instance (GHC.Show.Show key, GHC.Show.Show (Cardano.Address.Style.Byron.DerivationPath depth)) => GHC.Show.Show (Cardano.Address.Style.Byron.Byron depth key)
instance (GHC.Classes.Eq key, GHC.Classes.Eq (Cardano.Address.Style.Byron.DerivationPath depth)) => GHC.Classes.Eq (Cardano.Address.Style.Byron.Byron depth key)
instance (Control.DeepSeq.NFData key, Control.DeepSeq.NFData (Cardano.Address.Style.Byron.DerivationPath depth)) => Control.DeepSeq.NFData (Cardano.Address.Style.Byron.Byron depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Byron.Byron
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Byron.Byron
instance Cardano.Address.PaymentAddress Cardano.Address.Style.Byron.Byron
